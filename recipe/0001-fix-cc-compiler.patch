diff --git a/setup.py b/setup.py
index 3e52a961..2a1da149 100755
--- a/setup.py
+++ b/setup.py
@@ -79,7 +79,7 @@ else:
     fin, fout, ferr = (p.stdin, p.stdout, p.stderr)
     output = ferr.readlines()[-1].decode('utf8')
     try:
-        version = re.match('.*gcc version\s*(\d+).(\d+).(\d+).*', output).groups()
+        version = re.match(r'.*gcc version\s*(\d+).(\d+).(\d+).*', output).groups()
         if int(version[0]) < 4 or int(version[1]) < 2:
             print('Support for openMP is turned off because version %s.%s.%s of gcc does not support this feature' % version)
             USE_OPENMP = False
@@ -402,6 +402,8 @@ if not os.path.isdir('build'):
 
 COMMON_MACROS = [
     ('BOOST_UBLAS_NDEBUG', None),
+    ('BOOST_NO_CXX98_FUNCTION_BASE', None),
+    ('BOOST_COMPUTE_USE_CPP11', None),
     ('_HAS_ITERATOR_DEBUGGING', 0),
     ('BOOST_ALL_NO_LIB', None),
     ('NO_ZLIB', 0),
@@ -535,6 +537,7 @@ def try_compile(body='', ext='.cpp'):
             oldstderr = os.dup(sys.stderr.fileno())
             os.dup2(devnull.fileno(), sys.stderr.fileno())
             cc = new_compiler()
+            distutils.sysconfig.customize_compiler(cc)
             objects = cc.compile([fname], output_dir=tmpdir)
         except:
             return False
@@ -650,6 +653,7 @@ if __name__ == '__main__':
             # try to get
             print('Building static libraries')
             c = new_compiler(verbose=1)
+            distutils.sysconfig.customize_compiler(c)
             # -w suppress all warnings caused by the use of boost libraries
             objects = c.compile(LIB_FILES,
                 include_dirs=['gsl', 'gsl/specfunc', 'build', '.', boost_include_dir] + common_extra_include_dirs,
diff --git a/src/customizedTemplates.cpp b/src/customizedTemplates.cpp
index 2598be31..6eccfce8 100644
--- a/src/customizedTemplates.cpp
+++ b/src/customizedTemplates.cpp
@@ -63,7 +63,7 @@ template <typename T>
 PyObject *
 getarrayitem_template(struct arrayobject_template<T> * op, Py_ssize_t i)
 {
-	register struct arrayobject_template<T> * ap;
+	struct arrayobject_template<T> * ap;
 
 	assert(is_carrayobject_template<T>(op));
 	ap = (struct arrayobject_template<T> *)op;
@@ -77,7 +77,7 @@ template <>
 PyObject *
 getarrayitem_template<GenoIterator>(struct arrayobject_template<GenoIterator> * op, Py_ssize_t i)
 {
-	register struct arrayobject_template<GenoIterator> * ap;
+	struct arrayobject_template<GenoIterator> * ap;
 
 	assert(is_carrayobject_template<GenoIterator>(op));
 	ap = (struct arrayobject_template<GenoIterator> *)op;
@@ -746,7 +746,7 @@ template <typename T>
 PyObject *
 getarrayitem_template(PyObject * op, Py_ssize_t i)
 {
-	register struct arrayobject_template<T> * ap;
+	struct arrayobject_template<T> * ap;
 
 	assert(is_carrayobject_template<T>(op));
 	ap = (struct arrayobject_template<T> *)op;
@@ -1485,7 +1485,7 @@ template <>
 PyObject *
 getarrayitem_template<GenoIterator>(PyObject * op, Py_ssize_t i)
 {
-	register struct arrayobject_template<GenoIterator> * ap;
+	struct arrayobject_template<GenoIterator> * ap;
 
 	assert(is_carrayobject_template<GenoIterator>(op));
 	ap = (struct arrayobject_template<GenoIterator> *)op;
diff --git a/src/stator.h b/src/stator.h
index 0ac0640e..c26d6ff8 100644
--- a/src/stator.h
+++ b/src/stator.h
@@ -37,7 +37,6 @@
 #include <numeric>
 using std::string;
 using std::count_if;
-using std::bind2nd;
 using std::equal;
 using std::greater;
 using std::min;
diff --git a/src/utility.h b/src/utility.h
index 6769ae26..3aa5bbeb 100644
--- a/src/utility.h
+++ b/src/utility.h
@@ -1775,13 +1775,37 @@ void closeOutput(const string & output = string());
 class RNG_func
 {
 public:
+	typedef unsigned long int result_type;
+
 	RNG_func(gsl_rng * rng) : m_RNG(rng)
 	{
 
 	}
 
 
-	unsigned long int operator()(unsigned long int N) const
+#ifdef BOOST_COMPUTE_USE_CPP11
+	// somehow these functions needs to be static (callable from class), so
+	// min/max cannot change with the underlying m_RNG. However, we demand that
+	// RNGs generate full range of int to have a minimal range from 0 to
+	// MaxRandomNumber, so we can set the max to MaxRandomNumber.
+	constexpr static result_type min()
+	{
+		return 0;
+	}
+
+	constexpr static result_type max()
+	{
+		return MaxRandomNumber - 1;
+	}
+
+	result_type operator()()
+	{
+		return gsl_rng_uniform_int(m_RNG, MaxRandomNumber);
+	}
+
+#endif
+
+	result_type operator()(result_type N) const
 	{
 		return gsl_rng_uniform_int(m_RNG, N);
 	}
@@ -1981,7 +2005,12 @@ public:
 		// generator.
 		RNG_func rng(m_RNG);
 
+#ifdef BOOST_COMPUTE_USE_CPP11
+		std::shuffle(begin, end, rng);
+#else
 		std::random_shuffle(begin, end, rng);
+#endif
+
 	}
 
 
